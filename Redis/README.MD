# Redis知识点汇总

### Redis是什么？
Redis是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。

### MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据?
相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：

voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据

### redis的缓存失效策略和主键失效机制是怎么样的？


### 使用过Redis做异步队列么，你是怎么用的？
- 一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。 
- 如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。 
- 如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。 
- 如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。 

### redis如何实现延时队列？
使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。

### 如果有大量的key需要设置同一时间过期，一般需要注意什么？ 
如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。

### Redis的同步机制了解么？
Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，
复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

### 是否使用过Redis集群，集群的原理是什么？ 
- Redis Sentinal(哨兵模式)着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。 
- Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

### 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
redis-cli中输入: keys *xxx

如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？ redis的单线程的。keys指令会导致线程阻塞一段时间，
线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，
但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。



### 消费者处理任务的速度没有生产者生产任务快该怎么办？
出队列阻塞就是消费者的处理速度跟不上生产者产生的任务，加消费者提高处理速度。 

消费者加到极限还处理不过来，实在有爆内存的风险的时候，可以考虑将任务数据持久化（写入数据库），避免数据丢失，先把任务状态保存下来，根据具体业务做优化调整，等待异常问题解决之后再继续处理。使用支持持久化的队列消息，比如 rabbitmq

### redis过期键删除策略？
- 定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间到来时立即执行对键的删除操作。（可以及时释放内存，但是消耗cpu）
- 惰性删除：放任键的过期时间不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期，如果过期的话，就删除该键；如果没有过期就返回该键。（可能造成内存泄漏，一些不访问的键一直不删除）
- 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面过期的键（比较综合）。

redis使用的是**惰性删除＋定期删除策略**，使得合理使用cpu和内存使用上得到平衡。

### redis中的主从复制的策略是什么？
当一个从数据库启动时，会向主服务器发送sync命令，主数据收到命令之后会开始在后台保存快照（即RDB持久化过程）。并将保存快照期间接受到的命令缓存起来，当快照完成后，redis会将快照文件和缓存命令发给从服务器，从服务器接收到数据后，会载入快照文件并执行缓存命令，以上过程称为复制初始化，复制初始化之结束后，主数据库每收到写命令时就会将命令同步到从服务器，从服务器保证主从数据一致，这一过程称为复制同步过程。

### 什么是redis的主从读写分离？
一般来说，要将redis应用于一台服务器是万万不能的，原因如下：
1. 从结构上，单个redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大
2. 从容量上看，单个redis服务器内存容量有限，就算一台redis服务器内容容量为256G，也不能所有内容用作redis存储内存，一般来说，单台redis最大使用内存不应该超过20G

”多读少写”的架构应设计如下：

![](./1111.png)

我们将一台Redis服务器作主库，其他三台作为从库，主库只负责写数据，每次有数据更新都会将更新的数据同步到它所有的从库，而从库只负责读数据，这样一来，就有了2个好处：
1. 读写分离，不仅可以提高服务器的负载能力，并且可以根据读请求的规模自由增加或减少从库的数量；
2. 数据被赋值了好几份，就算有一台机器出现故障，也可以使用其他的机器的数据快速恢复


### redis的哨兵(sentinel)策略是怎么样的？新的master又是怎么选举出来？
哨兵(Sentinel) 是一个分布式系统，你可以在一个架构中运行多个哨兵(sentinel) 进程，这些进程使用流言协议(gossipprotocols)来接收关于Master主服务器是否下线的信息，并使用投票协议(Agreement Protocols)来决定是否执行自动故障迁移,以及选择哪个Slave作为新的Master。每个哨兵(Sentinel)进程会向其它哨兵(Sentinel)、Master、Slave定时发送消息，以确认对方是否”活”着，如果发现对方在指定配置时间(可配置的)内未得到回应，则暂时认为对方已掉线，也就是所谓的”主观认为宕机” ，英文名称：Subjective Down，简称SDOWN。有主观宕机，肯定就有客观宕机。当“哨兵群”中的多数Sentinel进程在对Master主服务器做出 SDOWN 的判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的Master Server下线判断，这种方式就是“客观宕机”，英文名称是：Objectively Down， 简称 ODOWN。通过一定的vote算法，从剩下的slave从服务器节点中，选一台提升为Master服务器节点，然后自动修改相关配置，并开启故障转移（failover）。

从“主观下线”状态切换到“客观下线”状态并没有使用严格的法定人数算法（strong quorum algorithm），而是使用了流言协议，该协议解释为：如果 Sentinel（哨兵）进程在给定的时间范围内，从其他 Sentinel（哨兵）进程那里接收到了足够数量的主服务器下线报告， 那么 Sentinel（哨兵）进程就会将主服务器的状态从“主观下线”改变为“客观下线”。如果之后其他 Sentinel（哨兵）进程不再报告主服务器已下线，那么“客观下线”状态就会被移除。

只要有一个 Sentinel（哨兵）进程发现某个主服务器进入了“客观下线”状态，这个 Sentinel（哨兵）进程就可能会被其他 Sentinel（哨兵）进程推选出，并对失效的主服务器执行自动故障迁移操作。
